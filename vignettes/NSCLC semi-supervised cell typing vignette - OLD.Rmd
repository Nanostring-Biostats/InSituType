---
title: "Use of insitutype in a small CosMx dataset"
output: 
  rmarkdown::html_vignette: 
    toc: true
fig_width: 10 
fig_height: 6 
vignette: >
  %\VignetteIndexEntry{Use of insitutype in a small CosMx dataset}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style>
p.caption {
  font-size: 1.5em;
}
</style>

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


## Vignette to-dos:
- add section at end on refineClusters function
- save clustering results in package data to save time when running?


### Installation

```{r installation, eval=FALSE}

# TBD

```

### Overview


This vignette demonstrates the use of the insitutype algorithm to perform cell typing 
of CosMx data. 

We'll analyze a subset of the CosMx NSCLC showcase dataset. 


### Data preparation

First, we load the package and access the example data:
```{r setup}
library(MLEcell)
data("ioprofiles")
data("iocolors")
data("mini_nsclc")
str(mini_nsclc)
set.seed(0)
```

#### Unsupervised clustering:

Let's begin with straightforward unsupervised clustering. 
We'll let the algorithm try to select the optimal number of clusters from 
a range of plausible options. 

```{r unsup, echo=FALSE}
unsup <- insitutype(counts = mini_nsclc$counts,
                    neg = Matrix::rowMeans(mini_nsclc$neg),
                    init_clust = NULL, 
                    n_clusts = c(5,7,10),  # condensed to save time. n_clusts = 5:20 would be more optimal
                    fixed_profiles = NULL,
                    anchors = NULL,
                    nb_size = 10,
                    n_phase1 = 200, n_phase2 = 500, n_phase3 = 2000, # choosing inadvisably low numbers to speed the vignette
                    n_starts = 2)   # 2 chosen to save time. 10 would be more thorough.

```

The function returns 3 useful outputs: a vector of cells' cluster assignments, 
a matrix of cells' probabilities of belonging to each cluster, and a matrix of 
the mean expression profile of each cluster. 

```{r unsup_results, fig.width = 10, fig.height = 6}
str(unsup)
round(head(unsup$probs),2)
heatmap(sweep(unsup$profiles, 1, apply(unsup$profiles, 1, max), "/"), scale = "none",
        main = "Cluster mean expression profiles")

# define cluster colors:
cols <- c('#8DD3C7','#BEBADA','#FB8072','#80B1D3','#FDB462','#B3DE69','#FCCDE5','#D9D9D9','#BC80BD','#CCEBC5','#FFED6F','#E41A1C','#377EB8','#4DAF4A','#984EA3','#FF7F00','#FFFF33','#A65628','#F781BF','#999999')
cols <- cols[seq_along(unique(unsup$clust))]
names(cols) <- unique(unsup$clust)

par(mfrow = c(1,2))
par(mar = c(0,0,3,0))

plot(mini_nsclc$x, mini_nsclc$y, pch = 16, cex = .75, asp = 1, cex.main = 0.75,
          main = "cells in physical space,\ncolored by unsupervised cluster",
     col = cols[unsup$clust], xlab = "", ylab = "", xaxt = "n", yaxt = "n")

plot(mini_nsclc$umap, pch = 16, cex = .75, asp = 1, cex.main = 0.75,
     main = "cells in UMAP space,\ncolored by unsupervised cluster",     
     col = cols[unsup$clust], xlab = "", ylab = "", xaxt = "n", yaxt = "n")
legend("bottomleft", pch = 16, col = cols, legend = names(cols), cex = 0.5)


```





#### Supervised cell typing:

Often, expression profiles will be available ahead of time for the cell types present in a tissue. 
Cell type expression profiles could come from earlier scRNA-seq studies, from singel cell expression 
databases like the human cell atlas, or from databases of cell type profiles like 
https://github.com/Nanostring-Biostats/CellProfileLibrary or https://github.com/northstaratlas/atlas_landmarks.

When we already know the expression profile of cells in a tissue, we can skip unsupervised clustering 
and simply assign each cell to the cell type under which its expression data is most likely
using the insitutypeML function. Below, we perform supervised cell typing using a matrix of immune cell profiles:


```{r sup, echo=FALSE}

sup <- insitutypeML(counts = mini_nsclc$counts,
                    neg = Matrix::rowMeans(mini_nsclc$neg),
                    fixed_profiles = ioprofiles)   
```

Now let's examine the results:
```{r sup_results, fig.width = 10, fig.height = 6}
str(sup)

par(mfrow = c(1,2))
par(mar = c(0,0,0,0))

plot(mini_nsclc$x, mini_nsclc$y, pch = 16, cex = .75, asp = 1, cex.main = 0.75,
     main = "cells in physical space,\ncolored by supervised cell type",
     col = iocolors[sup$clust], xlab = "", ylab = "", xaxt = "n", yaxt = "n")

plot(mini_nsclc$umap, pch = 16, cex = .75, asp = 1, cex.main = 0.75,
     main = "cells in UMAP space,\ncolored by supervised cell type",
     col = iocolors[sup$clust], xlab = "", ylab = "", xaxt = "n", yaxt = "n")
legend("bottomleft", pch = 16, col = iocolors, legend = names(iocolors), cex = 0.5)

```

There's a problem with the above plot: this is a tumor sample, but the profile matrix 
only contains profiles for immune and stroma cells. Any tumor cells will get assigned 
to whichever immune or stroma cell fits them best. 

#### Semi-supervised clustering

For settings like this one, where we only know the profiles for some of the cell types, we can employ 
semi-supervised clustering, in which the known cells types constrain a clustering solution 
that includes both pre-defined cell types and newly discovered clusters. 
To perform semi-supervised clustering, the insitutype algorithm identifies "anchor" cells
that are very good fits to the predefined profiles. Over the iterations, these 
cells are fixed within their originally assigned cell types, ", then holds these cells within
their assigned cell types as iterations proceed, anchoring their clusters. 

Below we'll perform semi-supervised clustering of the NSCLC sample, looking for 
known immune and stroma cell types while also fitting new clusters, presumably tumor cells: 

```{r semi}
semi <- insitutype(counts = mini_nsclc$counts,
                   neg = Matrix::rowMeans(mini_nsclc$neg),
                   init_clust = NULL, 
                   n_clusts = 2, 
                   fixed_profiles = ioprofiles,
                   anchors = NULL,
                   n_phase1 = 200, n_phase2 = 500, n_phase3 = 2000, # choosing inadvisably low numbers to speed the vignette
                   n_anchor_cells = 10,
                   nb_size = 10,
                   n_starts = 2)   
```


Now let's examine the results:

```{r semi_results, fig.width = 10, fig.height = 6}
str(semi)
unique(semi$clust)

# colors for known cell types:
cols = iocolors
# colors for new clusters
cols["a"] <- "grey20"
cols["b"] <- "firebrick"

par(mfrow = c(1,2))
par(mar = c(0,0,0,0))

plot(mini_nsclc$x, mini_nsclc$y, pch = 16, cex = .75, asp = 1, cex.main = 0.75,
     main = "cells in physical space,\ncolored by semi-supervised cell type",
     col = cols[semi$clust], xlab = "", ylab = "", xaxt = "n", yaxt = "n")

plot(mini_nsclc$umap, pch = 16, cex = .75, asp = 1, cex.main = 0.75,
     main = "cells in UMAP space,\ncolored by semi-supervised cell type",
     col = cols[semi$clust], xlab = "", ylab = "", xaxt = "n", yaxt = "n")
legend("bottomleft", pch = 16, col = cols, legend = names(cols), cex = 0.5)


```


#### Choosing anchor cells for semi-supervised clustering

In the above example of semi-supervised clustering, we let insitutype automatically 
choose anchor cells. Here we'll show how to select anchor cells ahead of insitutype. 
Anchor cells can be selected automatically with the function find_anchor_cells, 
or they can be selected by hand.

Now let's see how the find_anchor_cells function works:
```{r anchor}
anchors <- find_anchor_cells(counts = mini_nsclc$counts, 
                             neg = Matrix::rowMeans(mini_nsclc$neg), 
                             profiles = ioprofiles,
                             n_cells = 10, 
                             min_cosine = 0.3,
                             min_scaled_llr = 0.01)
str(anchors)
```

The output is a vector of cells' "anchor" assignments. Cells not chosen as anchors are given NA entries.

Below are the anchor cells selected. For each cell type, the top 10 cells have been chosen,
based on both cosine similarity to a fixed profile and likelihood ratio vs. other cell types.

```{r anchor_results, fig.width = 6, fig.height = 6}
cols = iocolors
cols["NA"] = "grey80"

plot(mini_nsclc$umap, pch = 16, cex = .5, asp = 1, cex.main = 0.75,
     main = "Autmated anchor cell choices", col = "grey80",
     xlab = "", ylab = "", xaxt = "n", yaxt = "n")
points(mini_nsclc$umap, pch = 16, cex = .75,
     col = cols[anchors])
legend("bottomleft", pch = 16, col = cols, legend = names(cols), cex = 0.5)

```


#### Visualizing clustering results

Insitutype calculates the probability of each cell belonging to each cluster. 
This information lets us understand how clusters relate to each other. 
The flightpath_plot function arrays cells according to their cluster probabilities:

```{r flightpath, fig.width = 5, fig.height = 5}
cols <- c('#8DD3C7','#BEBADA','#FB8072','#80B1D3','#FDB462','#B3DE69','#FCCDE5','#D9D9D9','#BC80BD','#CCEBC5','#FFED6F','#E41A1C','#377EB8','#4DAF4A','#984EA3','#FF7F00','#FFFF33','#A65628','#F781BF','#999999')
cols <- cols[seq_along(unique(unsup$clust))]
names(cols) <- unique(unsup$clust)
fp <- flightpath_plot(flightpath_result = NULL, insitutype_result = unsup, col = cols[unsup$clust])
class(fp)
print(fp)

```

Here we can see that clusters b and f are often confused. 

#### Merging closely related cell types

Sometimes it becomes clear that two clusters come from the same cell type. 
When this happens, it can be convenient to merge them. 

We might also want to delete a cluster from consideration, or sub-cluster a cell type. 

To get new cell type probabilities from merged/deleted/subclustered cell types, use the refineClusters function:

```{r refineClusters}
newprobs <- refineClusters(merges = c("a" = "newcluster", "b" = "newcluster"), 
                       probs = unsup$probs) 
str(newprobs)
```



### Session Info

```{r sessioninfo}
sessionInfo()
```